# Piece Square Tables, adapted from Sunfish.py:
# https://github.com/thomasahle/sunfish/blob/master/sunfish.py

"""
This script will contain the functions for the chess AI 
"""
import random as r

#Dictionnary to assign a score to the chessboard
pieceScore = { 
            'p': 100, 'N': 280, 'B': 320, 'R': 479, 'Q': 929, 'K': 60000, 'K_e': 60000, '-': 0 
            } 
CHECKMATE = 99999 #If we manage to get a ChekMate
STALEMATE = 0 #Because it is not a case that we want


'''
The pst matrix is taken from the github of thomasahle. Those value have been generated by try and error
pst_w = position table for with pawn in
pst_b = position table for black pawn
'''
pst_w = {
    'p':[
            [ 100, 100, 100, 100, 105, 100, 100,  100],
            [  78,  83,  86,  73, 102,  82,  85,  90],
            [   7,  29,  21,  44,  40,  31,  44,   7],
            [ -17,  16,  -2,  15,  14,   0,  15, -13],
            [ -26,   3,  10,   9,   6,   1,   0, -23],
            [ -22,   9,   5, -11, -10,  -2,   3, -19],
            [ -31,   8,  -7, -37, -36, -14,   3, -31],
            [   0,   0,   0,   0,   0,   0,   0,   0]
        ],
    'N': [ 
            [-66, -53, -75, -75, -10, -55, -58, -70],
            [ -3,  -6, 100, -36,   4,  62,  -4, -14],
            [ 10,  67,   1,  74,  73,  27,  62,  -2],
            [ 24,  24,  45,  37,  33,  41,  25,  17],
            [ -1,   5,  31,  21,  22,  35,   2,   0],
            [-18,  10,  13,  22,  18,  15,  11, -14],
            [-23, -15,   2,   0,   2,   0, -23, -20],
            [-74, -23, -26, -24, -19, -35, -22, -69]
        ],
    'B': [ 
            [-59, -78, -82, -76, -23,-107, -37, -50],
            [-11,  20,  35, -42, -39,  31,   2, -22],
            [ -9,  39, -32,  41,  52, -10,  28, -14],
            [ 25,  17,  20,  34,  26,  25,  15,  10],
            [ 13,  10,  17,  23,  17,  16,   0,   7],
            [ 14,  25,  24,  15,   8,  25,  20,  15],
            [ 19,  20,  11,   6,   7,   6,  20,  16],
            [ -7,   2, -15, -12, -14, -15, -10, -10]
        ],
    'R': [  
            [ 35,  29,  33,   4,  37,  33,  56,  50],
            [ 55,  29,  56,  67,  55,  62,  34,  60],
            [ 19,  35,  28,  33,  45,  27,  25,  15],
            [  0,   5,  16,  13,  18,  -4,  -9,  -6],
            [-28, -35, -16, -21, -13, -29, -46, -30],
            [-42, -28, -42, -25, -25, -35, -26, -46],
            [-53, -38, -31, -26, -29, -43, -44, -53],
            [-30, -24, -18,   5,  -2, -18, -31, -32]
        ],
    'Q': [   
            [  6,   1,  -8,-104,  69,  24,  88,  26],
            [ 14,  32,  60, -10,  20,  76,  57,  24],
            [ -2,  43,  32,  60,  72,  63,  43,   2],
            [  1, -16,  22,  17,  25,  20, -13,  -6],
            [-14, -15,  -2,  -5,  -1, -10, -20, -22],
            [-30,  -6, -13, -11, -16, -11, -16, -27],
            [-36, -18,   0, -19, -15, -15, -21, -38],
            [-39, -30, -31, -13, -31, -36, -34, -42]
        ],
    'K': [  
            [  4,  54,  47, -99, -99,  60,  83, -62],
            [-32,  10,  55,  56,  56,  55,  10,   3],
            [-62,  12, -57,  44, -67,  28,  37, -31],
            [-55,  50,  11,  -4, -19,  13,   0, -49],
            [-55, -43, -52, -28, -51, -47,  -8, -50],
            [-47, -42, -43, -79, -64, -32, -29, -32],
            [ -4,   3, -14, -50, -57, -18,  13,   4],
            [ 17,  30,  -3, -14,   6,  -1,  40,  18]
        ],

    #Endgame King Table
    'K_e': [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10,   0,   0, -10, -20, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -30,   0,   0,   0,   0, -30, -30],
            [-50, -30, -30, -30, -30, -30, -30, -50]
        ]
}

pst_b = {}
for key, matrix in pst_w.items():
    pst_b[key] = matrix[::-1]


'''
Find a random move
'''
def find_random_move(valid_moves):
    '''
    Function that will select a random element in the list of valid moves
    '''
    return valid_moves[r.randint(0, len(valid_moves)-1)]

'''
Find the best move based on material alone
'''
def find_best_moves(gs, valid_moves):
    '''
    Function that will apply a Minimax algorithm (Greedy Algorithm) to the list of valid movements 
    based on material alone
    '''
    # What is good for white is bad for black and what is good for black is bad for white
    # Black turn want to have the smallest value, a negatif value (ex: -9999)
    #   -> we provide a positif value for the turn_multiplier because the black player want to
    #       to decrease his score and reach the negatif values
    # White turn want to have the highest value, a positive value (ex: 9999)
    #   -> we provide a negatif value for the turn_multiplier because the white player want to
    #       to increase his score and reach the positif values
    turn_multiplier = 1 if gs.whiteToMove else -1 
    opponent_MinMax_score = CHECKMATE #for black perspective
    best_player_move = None
    #r.shuffle(valid_moves)
    for player_move in valid_moves:  
        gs.make_move(player_move) #the AI make his move
        opponent_moves = gs.get_valid_moves() #possible moves for the opponent after the AI moved
        opponent_max_score = -CHECKMATE #set the opponent max move score to a very low value
        for opponent_move in opponent_moves: #i am trying to find the max value of the opponent moves
            gs.make_move(opponent_move) #the opponent makes his move
            if gs.checkMate:
                score = -turn_multiplier * CHECKMATE
            elif gs.staleMate:
                score = STALEMATE
            else:
                score = -turn_multiplier * score_material(gs.board)
            if score > opponent_max_score : #IS it larger than the max value gathered so far?
                opponent_max_score = score #if so, that become my max value
            gs.undo_move() #undo the opponent move

        if opponent_max_score < opponent_MinMax_score: #if the max oppoenent respond to my move
            #If the max opponent respond to my move is lower than the their previous best score
            #That value, become now their MinMax value that i want to minimize
            opponent_MinMax_score = opponent_max_score
            best_player_move = player_move

        gs.undo_move()#undo the AI move
    
    return best_player_move


'''
Score the board vased on the material
'''
def score_material(board):
    '''
    Score the board vased on the material
    '''    
    score = 0
    #What is good for white is bad for black and what is good for black is bad for white
    for row in range(len(board)): #loop among the rows in the board
        for col in range(len(board[row])):  #loop in each col in a row
            piece_type = board[row][col][1] #letter of the piece
            color_piece = board[row][col][0]
            if color_piece == 'w':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the white position matrix !!!
                score += (pieceScore[piece_type] + pst_w[piece_type][row][col])
            elif color_piece == 'b':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the black position matrix !!!
                score -= (pieceScore[piece_type] + pst_b[piece_type][row][col])
    
    return score
