# Piece Square Tables, adapted from Sunfish.py:
# https://github.com/thomasahle/sunfish/blob/master/sunfish.py

"""
This script will contain the functions for the chess AI 
"""
import random as r

#Dictionnary to assign a score to the chessboard
pieceScore = { 
            'p': 100, 'N': 280, 'B': 320, 'R': 479, 'Q': 929, 'K': 60000, 'K_e': 60000, '-': 0 
            } 
CHECKMATE = 99999 #If we manage to get a ChekMate
STALEMATE = 0 #Because it is not a case that we want
DEPTH = 3


'''
The pst matrix is taken from the github of thomasahle. Those value have been generated by try and error
pst_w = position table for with pawn in
pst_b = position table for black pawn
'''
pst_w = {
    'p':[
            [ 100, 100, 100, 100, 105, 100, 100,  100],
            [  78,  83,  86,  73, 102,  82,  85,  90],
            [   7,  29,  21,  44,  40,  31,  44,   7],
            [ -17,  16,  -2,  15,  14,   0,  15, -13],
            [ -26,   3,  10,   9,   6,   1,   0, -23],
            [ -22,   9,   5, -11, -10,  -2,   3, -19],
            [ -31,   8,  -7, -37, -36, -14,   3, -31],
            [   0,   0,   0,   0,   0,   0,   0,   0]
        ],
    'N': [ 
            [-66, -53, -75, -75, -10, -55, -58, -70],
            [ -3,  -6, 100, -36,   4,  62,  -4, -14],
            [ 10,  67,   1,  74,  73,  27,  62,  -2],
            [ 24,  24,  45,  37,  33,  41,  25,  17],
            [ -1,   5,  31,  21,  22,  35,   2,   0],
            [-18,  10,  13,  22,  18,  15,  11, -14],
            [-23, -15,   2,   0,   2,   0, -23, -20],
            [-74, -23, -26, -24, -19, -35, -22, -69]
        ],
    'B': [ 
            [-59, -78, -82, -76, -23,-107, -37, -50],
            [-11,  20,  35, -42, -39,  31,   2, -22],
            [ -9,  39, -32,  41,  52, -10,  28, -14],
            [ 25,  17,  20,  34,  26,  25,  15,  10],
            [ 13,  10,  17,  23,  17,  16,   0,   7],
            [ 14,  25,  24,  15,   8,  25,  20,  15],
            [ 19,  20,  11,   6,   7,   6,  20,  16],
            [ -7,   2, -15, -12, -14, -15, -10, -10]
        ],
    'R': [  
            [ 35,  29,  33,   4,  37,  33,  56,  50],
            [ 55,  29,  56,  67,  55,  62,  34,  60],
            [ 19,  35,  28,  33,  45,  27,  25,  15],
            [  0,   5,  16,  13,  18,  -4,  -9,  -6],
            [-28, -35, -16, -21, -13, -29, -46, -30],
            [-42, -28, -42, -25, -25, -35, -26, -46],
            [-53, -38, -31, -26, -29, -43, -44, -53],
            [-30, -24, -18,   5,  -2, -18, -31, -32]
        ],
    'Q': [   
            [  6,   1,  -8,-104,  69,  24,  88,  26],
            [ 14,  32,  60, -10,  20,  76,  57,  24],
            [ -2,  43,  32,  60,  72,  63,  43,   2],
            [  1, -16,  22,  17,  25,  20, -13,  -6],
            [-14, -15,  -2,  -5,  -1, -10, -20, -22],
            [-30,  -6, -13, -11, -16, -11, -16, -27],
            [-36, -18,   0, -19, -15, -15, -21, -38],
            [-39, -30, -31, -13, -31, -36, -34, -42]
        ],
    'K': [  
            [  4,  54,  47, -99, -99,  60,  83, -62],
            [-32,  10,  55,  56,  56,  55,  10,   3],
            [-62,  12, -57,  44, -67,  28,  37, -31],
            [-55,  50,  11,  -4, -19,  13,   0, -49],
            [-55, -43, -52, -28, -51, -47,  -8, -50],
            [-47, -42, -43, -79, -64, -32, -29, -32],
            [ -4,   3, -14, -50, -57, -18,  13,   4],
            [ 17,  30,  -3, -14,   6,  -1,  40,  18]
        ],

    #Endgame King Table
    'K_e': [
            [-50, -40, -30, -20, -20, -30, -40, -50],
            [-30, -20, -10,   0,   0, -10, -20, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  30,  40,  40,  30, -10, -30],
            [-30, -10,  20,  30,  30,  20, -10, -30],
            [-30, -30,   0,   0,   0,   0, -30, -30],
            [-50, -30, -30, -30, -30, -30, -30, -50]
        ]
}

pst_b = {}
for key, matrix in pst_w.items():
    pst_b[key] = matrix[::-1]


'''
Find a random move
'''
def find_random_move(valid_moves):
    '''
    Function that will select a random element in the list of valid moves
    '''
    return valid_moves[r.randint(0, len(valid_moves)-1)]

'''
Find the best move based on material alone
'''

def find_best_moves_noRecursion(gs, valid_moves):
    '''
    Function that will apply a Minimax algorithm (Greedy Algorithm) to the list of valid movements 
    based on material alone
    '''
    # What is good for white is bad for black and what is good for black is bad for white
    # Black turn want to have the smallest value, a negatif value (ex: -9999)
    #   -> we provide a positif value for the turn_multiplier because the black player want to
    #       to decrease his score and reach the negatif values
    # White turn want to have the highest value, a positive value (ex: 9999)
    #   -> we provide a negatif value for the turn_multiplier because the white player want to
    #       to increase his score and reach the positif values
    turn_multiplier = 1 if gs.whiteToMove else -1 
    opponent_MinMax_score = CHECKMATE #for black perspective
    best_player_move = None
    r.shuffle(valid_moves)
    for player_move in valid_moves:  
        gs.make_move(player_move) #the AI make his move
        opponent_moves = gs.get_valid_moves() #possible moves for the opponent after the AI moved
        if gs.checkMate:
            opponent_max_score = -CHECKMATE
        elif gs.staleMate:
            opponent_max_score = STALEMATE
        else:        
            opponent_max_score = -CHECKMATE #set the opponent max move score to a very low value
            for opponent_move in opponent_moves: #i am trying to find the max value of the opponent moves
                gs.make_move(opponent_move) #the opponent makes his move
                gs.get_valid_moves() 
                # we need to generate all the possible moves in order to determine when
                # we are in a checkMAte or StaleMate states
                if gs.checkMate:
                    score = CHECKMATE
                elif gs.staleMate:
                    score = STALEMATE
                else:
                    score = -turn_multiplier * score_material(gs.board)
                if score > opponent_max_score : #IS it larger than the max value gathered so far?
                    opponent_max_score = score #if so, that become my max value
                gs.undo_move() #undo the opponent move
            
        if opponent_max_score < opponent_MinMax_score: #if the max oppoenent respond to my move
            #If the max opponent respond to my move is lower than the their previous best score
            #That value, become now their MinMax value that i want to minimize
            opponent_MinMax_score = opponent_max_score
            best_player_move = player_move

        gs.undo_move()#undo the AI move
    
    return best_player_move

'''
Helper method to make the first recursive call
'''
def find_best_moves(gs, valid_moves):
    '''
    Function that will call the initial recursive call and return the result at the end
    '''
    global next_move
    next_move = None
    #find_move_MinMax(gs, valid_moves, DEPTH, gs.whiteToMove)
    #find_move_MinMax_alpha_beta(gs, valid_moves, DEPTH, -CHECKMATE, CHECKMATE, gs.whiteToMove)
    #find_move_NegaMax(gs, valid_moves, DEPTH)
    find_move_NegaMax_alpha_beta(gs, valid_moves, DEPTH, -CHECKMATE, CHECKMATE)

    return next_move

'''
Recursive function to find the best move
'''
def find_move_MinMax(gs, valid_moves, depth, whiteToMove):
    '''
    depth: represent how deep we want the AI go look forward
    '''
    global next_move
    if depth == 0: 
        return score_board(gs)
    if whiteToMove:
        max_score = -CHECKMATE
        for move in valid_moves:
            gs.make_move(move)
            next_moves = gs.get_valid_moves()
            score = find_move_MinMax(gs,next_moves, depth-1, False) #False = not whiteToMove
            if score > max_score:
                max_score = score
                if depth == DEPTH:  #when we have look for all the lower branches 
                                    #(depth 0, 1, ..., DEPTH)
                    next_move = move #THE best move to make
            gs.undo_move()
        return max_score

    else:
        min_score = CHECKMATE
        for move in valid_moves:
            gs.make_move(move)
            next_moves = gs.get_valid_moves()
            score = find_move_MinMax(gs,next_moves, depth-1, True) #True = whiteToMove
            if score < min_score:
                min_score = score
                if depth == DEPTH:  #when we have look for all the lower branches 
                                    #(depth 0, 1, ..., DEPTH)
                    next_move = move #THE best move to make
            gs.undo_move()
        return min_score

def find_move_NegaMax(gs,valid_moves,depth):
    '''
    Function that will apply the negamax algorithm to simplify the coding of the minimax 
    algorithm. The 'color' parameter will make the script alternate between each color.
    color = 1 for the first player and -1 for the opponent. 
    Negamax algorithm relies on the fact that max(player1) = -min(-player2).
    Thus, simplify the implementation of the minimax algorithm
    '''
    global next_move
    
    color = 1 if gs.whiteToMove else -1
    if depth == 0: 
        return color * score_board(gs) 
    max_score = -CHECKMATE
    r.shuffle(valid_moves)
    for move in valid_moves:
        gs.make_move(move)
        next_moves = gs.get_valid_moves()
        score = - find_move_NegaMax(gs,next_moves, depth-1)
        if score > max_score:
            max_score = score
            if depth == DEPTH:  #when we have look for all the lower branches 
                                #(depth 0, 1, ..., DEPTH)
                next_move = move #THE best move to make
        gs.undo_move()
    return max_score

def find_move_NegaMax_alpha_beta(gs,valid_moves,depth, alpha, beta):
    '''
    Function that will apply the negamax algorithm to simplify the coding of the minimax 
    algorithm. The 'color' parameter will make the script alternate between each color.
    color = 1 for the first player and -1 for the opponent. 
    Negamax algorithm relies on the fact that max(player1) = -min(-player2).
    Thus, simplify the implementation of the minimax algorithm
    '''
    global next_move
    
    color = 1 if gs.whiteToMove else -1
    if depth == 0: 
        return color * score_board(gs) 
    max_score = -CHECKMATE
    r.shuffle(valid_moves)
    for move in valid_moves:
        gs.make_move(move)
        next_moves = gs.get_valid_moves()
        score = - find_move_NegaMax_alpha_beta(gs,next_moves, depth-1, -beta, -alpha)
        #we need to call beta instead of alpha to alternate their values.
        if score > max_score:
            max_score = score
            if depth == DEPTH:  #when we have look for all the lower branches 
                                #(depth 0, 1, ..., DEPTH)
                next_move = move #THE best move to make
        gs.undo_move()

        if score > alpha:
            alpha = score
            if alpha >= beta:
                break
        

    return max_score

def find_move_MinMax_alpha_beta(gs, valid_moves, depth, alpha, beta, whiteToMove):
    '''
    This function will apply the minimax algorithm with the alpha-beta pruning
        alpha : worst case value for white
        beta : worst case value for black
    '''
    global next_move
    if depth == 0: 
        return score_board(gs)
    if whiteToMove:
        max_score = -CHECKMATE
        for move in valid_moves:
            gs.make_move(move)
            next_moves = gs.get_valid_moves()
            score = find_move_MinMax_alpha_beta(gs,next_moves, depth-1, alpha, beta, False) #False = not whiteToMove
            if score > max_score:
                max_score = score
                if depth == DEPTH:  #when we have look for all the lower branches 
                                    #(depth 0, 1, ..., DEPTH)
                    next_move = move #THE best move to make            
            gs.undo_move()

            alpha = max(alpha, score)
            if beta <= alpha:
                break

        return max_score

    else:
        min_score = CHECKMATE
        for move in valid_moves:
            gs.make_move(move)
            next_moves = gs.get_valid_moves()
            score = find_move_MinMax_alpha_beta(gs,next_moves, depth-1, alpha, beta, True) #True = whiteToMove
            if score < min_score:
                min_score = score
                if depth == DEPTH:  #when we have look for all the lower branches 
                                    #(depth 0, 1, ..., DEPTH)
                    next_move = move #THE best move to make            
            gs.undo_move()

            beta = min(beta, score)
            if beta <= alpha:
                break

        return min_score

'''
Functions to score the board
'''
def score_board(gs):
    '''
    Function that will evaluate the board completely
        1) positif score : good for white -> white winning
        2) negatif score : good for black -> black is winning
    '''
    #1) checking the terminal node
    #By checking the checkMate and staleMate states in the 'score_board' function, we don't  
    #need to check it in the 'find_best_moves' function
    if gs.checkMate:
    #There is no need to calculate the score of the board if we are in a checkMate state
        if gs.whiteToMove:
            return -CHECKMATE #black wins
        else:
            return CHECKMATE #white wins
    elif gs.staleMate:
        return STALEMATE

    #2) Evaluate the board
    score = 0
    #What is good for white is bad for black and what is good for black is bad for white
    for row in range(len(gs.board)): #loop among the rows in the board
        for col in range(len(gs.board[row])):  #loop in each col in a row
            piece_type = gs.board[row][col][1] #letter of the piece
            color_piece = gs.board[row][col][0]
            if color_piece == 'w':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the white position matrix !!!
                score += (pieceScore[piece_type] + pst_w[piece_type][row][col])
            elif color_piece == 'b':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the black position matrix !!!
                score -= (pieceScore[piece_type] + pst_b[piece_type][row][col])
    
    return score

'''
Score the board vased on the material
'''
def score_material(board):
    '''
    Score the board vased on the material
    '''    
    score = 0
    #What is good for white is bad for black and what is good for black is bad for white
    for row in range(len(board)): #loop among the rows in the board
        for col in range(len(board[row])):  #loop in each col in a row
            piece_type = board[row][col][1] #letter of the piece
            color_piece = board[row][col][0]
            if color_piece == 'w':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the white position matrix !!!
                score += (pieceScore[piece_type] + pst_w[piece_type][row][col])
            elif color_piece == 'b':
                #we'll sum the pieceScore with the position weight of the piece
                # !! use the black position matrix !!!
                score -= (pieceScore[piece_type] + pst_b[piece_type][row][col])
    
    return score
